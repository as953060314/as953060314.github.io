<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[homework_of_scipy]]></title>
    <url>%2F2018%2F06%2F05%2Fhomework-of-scipy%2F</url>
    <content type="text"><![CDATA[Homework of Scipy1 12345678910from scipy import linalg as ln import scipyimport numpy as np 。。m=10n=5A=scipy.random.rand(m,n)b=scipy.random.rand(m,1)x,residual,s,d=scipy.linalg.lstsq(A, b)print(x)print(residual/n) 结果123456[[ 0.87094822] [-0.32218525] [ 0.73725433] [-0.37806776] [ 0.13787547]][0.20063421] 解析与numpy相似，scipy的linalg类用于求解线性函数。其中lstsq（）函数用于求解$Ax=b$的最小二乘问题，返回值分别是对应的x向量，以及残差。因为这是矩阵方程，所以需要除以n得到残差的标准化。 21234567891011121314import scipyimport scipy.linalgimport scipy.spatialimport scipy.optimize as optimport mathimport numpy as np import matplotlib.pyplot as pltdef f(x): return -np.sin(x-2)*np.sin(x-2)*np.exp(-x*x)y=opt.fmin(f, 0)print(y) 结果12345Optimization terminated successfully. Current function value: -0.911685 Iterations: 20 Function evaluations: 40[0.21625] 解析scipy的optimize模块通常用于优化和求最小值，所以没有直接的函数可以求最大值。解决的方法是把定义的函数的返回值取负，那么直接使用optimize中的fmin函数可以求出$-f(x)$的最小值，即为$f(x)$的最大值，第二个参数指从哪里开始寻找最小值，因为fmin是通过不动点迭代不断逼近实现的，所以需要指定一个点。 3123456789101112131415import scipyimport scipy.linalgimport scipy.spatialimport scipy.optimize as optimport mathimport numpy as np import matplotlib.pyplot as pltm = 5n = 4X = scipy.random.rand(n, m) * scipy.random.randint(1, 10)print(X)print('\n')Y = scipy.spatial.distance.pdist(X)print(Y) 结果1234567[[6.9076098 3.72595383 5.17263951 8.91157639 1.57053659] [7.3818894 0.40836655 8.93873029 0.19993967 6.3668335 ] [0.75542118 0.92476136 8.62267228 8.48863087 3.24609955] [0.32856337 5.98210304 7.54709297 1.90966592 7.54602284]][11.14952216 7.78365108 11.77901848 11.07781655 9.33092987 9.41742551] 解析scipy中的spatial模块主要解决空间几何问题，其中的distance解决空间距离问题，pdist（）函数的第二个参数缺失时默认为求欧拉距离，及$m*n$的X矩阵中，每一行代表一个n维空间的坐标，padist可用于求出X矩阵中任意两行之间的距离，返回一个列表，内含任意两行之间的距离。]]></content>
      <categories>
        <category>homework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[homework_matplotlib]]></title>
    <url>%2F2018%2F05%2F29%2Fhomework-matplotlib%2F</url>
    <content type="text"><![CDATA[Homework of Matplotlib1234567891011import numpy as np import matplotlib . pyplot as pltx=np.linspace(0,2,1000,endpoint=True)C=np.square( np.sin(x-2) )*np.exp(-np.square(x))plt.xlabel ( 'my x label' ) #设置x轴名称plt.ylabel ( 'my y label ' ) #设置y轴名称plt.title('my title') #设置标题plt.tight_layout() #规范名称，防止显示不全plt.plot(x,C) #画出图像plt.savefig("1.png") #把画出的图像保存plt.show() #展示结果 12345678910111213141516171819202122import numpy as npimport matplotlib.pyplot as pltX=np.random.randint(0,20,(20,10))b=np.random.randint(0,5,(10,1))z=np.random.normal(size=[20,1])y=np.dot(X,b)+zprint(y)b_=np.linalg.lstsq(X, y, rcond=None)[0] #使用最小二乘法获得b^print(b_)s_b=b.Ts_b_=b_.Tx = list(range(1,11))plt.scatter(x, s_b, c='b', marker='o', label='true parameters')#画出b的散点图plt.scatter(x, s_b_, c='r', marker='x', label='estimated parameters')#画出b^的散点图plt.legend()#展示图例，指明那个点代笔那个数值plt.xlabel('index')plt.ylabel('value')plt.savefig('2.png')plt.show() 1234567import numpy as npimport matplotlib.pyplot as pltf , ax = plt . subplots (1 , 1, figsize=(6,3))z=np.random.randn(10000)ax.hist(z,bins=25,normed=True,color="b")#画出直方图，bins设为25plt.savefig('3.png')plt.show()]]></content>
      <categories>
        <category>homework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Homework of Numpy]]></title>
    <url>%2F2018%2F05%2F21%2Fhomework-numpy%2F</url>
    <content type="text"><![CDATA[Homework of Numpy 12345678910111213141516171819import numpy as np n=200m=500A=np.random.normal(size=[n,m])print(np.mean(A))print(np.var(A))def toeplitz(x,y): toeplitz_matrix=np.zeros([len(x),len(y)]) for i in range(len(x)): for j in range(len(y)-i): toeplitz_matrix[j][j+i]=y[i];#取y的第i个元素，作为第i列开始的斜线上的值 for j in range(i,len(x)): toeplitz_matrix[j][j-i]=x[i]; #取x的第i个元素，作为第i行开头的斜线上的值 return toeplitz_matrixvectorX=np.random.normal(size=[m])vectorY=np.random.normal(size=[m])B=toeplitz(vectorX,vectorY) #测试函数 调用numpy模块中的random的normal函数可随机生成指定大小的服从高斯分布的矩阵根据toeplitz矩阵的性质，传入两个随机向量x,y作为生成矩阵的基础。因为toelitz矩阵的性质是a[i][j]=a[i-1][j-1],使用两个循环分别生成对角线上半部分与对角线下半部分的矩阵。 1234567sum_A_A=A+Amul_A_AT=np.matmul(A,A.transpose())mul_AT_A=np.matmul(A.transpose(),A)mul_A_B=np.matmul(A,B)I=np.eye([len(B),len(B)])constant=7mul_A_B_I=np.matmul(A,B-constant*I) A、B采用刚开始生成的A、B矩阵，因为python的支持矩阵的加减，所以直接加减即可，numpy提供matmul函数用于矩阵相乘123456789数据过多，不予显示``` ---------------------------------------------------- ![](https://raw.githubusercontent.com/as953060314/picture/master/2018-05-21_222859.png)```pyb=random.random(size=[m])x=np.linalg.solve(B,b) numpy.linalg用于矩阵求逆，行列数和求解方程等问题，其中solve函数用于求解方程 结果123456[1.20120856e-01 4.41123209e-02 2.04747755e-02 -3.07493851e-03 6.42280172e-02 8.93103284e-02 -7.19149485e-02 -8.56545532e-02-3.00182149e-02 4.58770228e-02 -4.97305732e-03 -4.13289742e-02 6.08289103e-02 -1.97740723e-02 4.54804478e-02 9.47587969e-02-3.23121795e-02 2.07067072e-02 1.88935042e-02 7.10890707e-02-2.23007296e-02 -2.89321197e-02 -6.86733343e-02 6.31168495e-03...more data] 1234Frobenius_norm_A=np.linalg.norm(A,"fro")infinity_norm=np.linalg.norm(B,np.inf)max_B=np.max(B)min_B=np.min(B) numpy.linalg提供求范数（norm）的函数norm，第一个参数代表需要求范数的矩阵，第二个参数代表需要求哪一种类型的范数 结果1234317.5813609674095394.432389419546673.2240185505846477-3.2887955774704363 123456789101112131415161718192021222324import timedef power_interaion(Z,stop): #Z为目标矩阵 u= np.random.normal(size=[len(Z)]).transpose() u=u/np.max(u) #规范化u,防止计算过程产生溢出 v=u.copy() change=np.inf val=np.max(v) #生成v0,change初始化为无限大 iteration=0 #记录迭代次数 s_time=time.clock() #记录开始时间 while abs(change)&gt;stop: #当误差大于要求值时，继续迭代 v=np.matmul(Z,u) max_v=np.max(v) change=val-max_v val=max_v u=v/max_v #利用uk得出uk+1 iteration+=1 return [val,u,iteration,time.clock()-s_time] numpy并没有提供实现幂迭代的函数接口，所以需要我们自己实现幂迭代获得特征值。根据幂迭代的算法，随机生成一个初始向量u，把u单位化，记录开始的时间。根据幂迭代的定理，最大特征值为lim(k-&gt;无穷)max(uk)，当两次求出的值的差小于要求误差时，说明迭代得出了符合要求的结果。 测试代码12Z=np.random.random(size=[5,5])print(power_interaion(Z,1e-8)) 结果1[2.70827538375684, array([1. , 0.44946869, 0.77024251, 0.82104694, 0.55418511]), 18, 0.00015178781121221067] 1234567891011p_all=[0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9]for p in p_all: C=np.random.random(size=[n,n]) for i in range(n): for j in range(n): C[i][j]=1 if C[i][j]&gt;p else 0 _,s,_=np.linalg.svd(C) max_singular=np.max(s) print("n=&#123;&#125;, p=&#123;&#125;, max_singular=&#123;&#125;".format(n,p,max_singular)) 定义一个关于p的列表，给p不同的初值以观察n,p和最大奇异值之间的关系。根据题目生成矩阵Cnumpy提供了对矩阵进行svd分解的函数svd，返回值是酉矩阵，奇异值列表与酉矩阵。使用max函数获得最大的奇异值。 结果如下：123456789n=1000, p=0.1, max_singular=900.3295011412832n=1000, p=0.2, max_singular=799.9151077913688n=1000, p=0.3, max_singular=700.3536328393312n=1000, p=0.4, max_singular=601.2824981484671n=1000, p=0.5, max_singular=499.97072982587673n=1000, p=0.6, max_singular=400.1535461744695n=1000, p=0.7, max_singular=300.73085868276326n=1000, p=0.8, max_singular=200.62285503617426n=1000, p=0.9, max_singular=101.05219949564113 根据观察，最大奇异值与n,p之间的关系是max_singular=n*(1-p) 123def nearest(matrix_A,z): idx=np.argmin(np.abs(matrix_A-z)) return matrix_A[idx//np.shape(matrix_A)[0]][idx%np.shape(matrix_A)[1]] 根据提示，把矩阵matrix_A里的每一个元素都减去z,然后获得所得矩阵中绝对值最小的元素的索引，该索引代表的元素即使与z的值最接近的元素。 测试代码12matrix_A=np.random.random(size=[10,10])print(nearest(matrix_A,5)) 结果123456789101112131415161718192021[[0.93059739 0.00876511 0.70560925 0.2388774 0.1925587 0.13501147 0.67538026 0.45353334 0.56005308 0.42424492] [0.15135289 0.03206525 0.43530632 0.34864683 0.11803917 0.61252708 0.63750012 0.91986518 0.73333553 0.41027809] [0.21912262 0.92825151 0.41417121 0.61705986 0.01896161 0.74536994 0.30234905 0.29492359 0.20047288 0.65651576] [0.46347628 0.70735148 0.06351783 0.29542927 0.75189968 0.19221456 0.30014604 0.99659958 0.95334689 0.94916713] [0.41139929 0.92399863 0.50937552 0.49099935 0.7323332 0.07490913 0.6600088 0.49095145 0.19368513 0.38531681] [0.8886216 0.39987914 0.021721 0.85508795 0.35473727 0.26547035 0.68853818 0.47236815 0.13444103 0.66512414] [0.34325048 0.36774161 0.8862545 0.47320286 0.70253863 0.32501771 0.44267665 0.01853662 0.141236 0.32341546] [0.76944986 0.83380353 0.43924792 0.14467297 0.78263698 0.86952456 0.52818544 0.16549051 0.06783422 0.02373907] [0.31989803 0.29975767 0.82193047 0.96154146 0.04192064 0.40480152 0.2914697 0.2935967 0.00327249 0.04784899] [0.33077118 0.04194136 0.61841141 0.02789121 0.51963424 0.53040265 0.65079491 0.92001641 0.4433936 0.13753367]]0.9965995800963104]]></content>
      <categories>
        <category>homework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Homework_week8]]></title>
    <url>%2F2018%2F04%2F30%2FHomework-week8%2F</url>
    <content type="text"><![CDATA[Homework Week 8LeetCode 55. Jump GameQUESTION:Given an array of non-negative integers, you are initially positioned at the first index of the array.Each element in the array represents your maximum jump length at that position.Determine if you are able to reach the last index. Example 1:Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.Example 2:Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. Code12345678910111213class Solution: def canJump(self, nums): """ :type nums: List[int] :rtype: bool """ far_max=nums[0] for i in range(len(nums)): if far_max&lt;i: return False far_max=nums[i]+i if nums[i]+i+1&gt;far_max else far_max return True Explanation遍历数组，计算每一个位置可跳到的最大距离，比较保存他们之间的最大值，当发现可以到达的最远距离已经小于当前位置，说明无法从之前的任意一个地方到达目前位置，说明无法到达最后一项 LeetCode 63. Unique Paths IIQUESTION: A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). Now consider if some obstacles are added to the grids. How many unique paths would there be? An obstacle and empty space is marked as 1 and 0 respectively in the grid. Note: m and n will be at most 100. Example 1: Input:[ [0,0,0], [0,1,0], [0,0,0]]Output: 2Explanation:There is one obstacle in the middle of the 3x3 grid above.There are two ways to reach the bottom-right corner: Right -&gt; Right -&gt; Down -&gt; Down Down -&gt; Down -&gt; Right -&gt; Right Code1234567891011121314151617181920212223class Solution: def uniquePathsWithObstacles(self, obstacleGrid): """ :type obstacleGrid: List[List[int]] :rtype: int """ m=len(obstacleGrid) n=len(obstacleGrid[0]) road=[ [0 for i in range(n)] for i in range(m)] for i in range(m): for j in range(n): if i==0 and j==0: road[i][j]=1 if obstacleGrid[i][j] != 1 else 0 elif i==0: road[i][j]=road[i][j-1] if obstacleGrid[i][j] != 1 else 0 elif j==0: road[i][j]=road[i-1][j] if obstacleGrid[i][j] != 1 else 0 else: if obstacleGrid[i][j] != 1: road[i][j]=road[i-1][j]+road[i][j-1] #print(road) return road[m-1][n-1] Explanation先抛开开头结尾，只看地图格子上的一个可通行的格子。机器人只可往下或往右走，那么说明到达一个格子的方法只有两个，分别是road[i-1][j]或road[i][j-1]，这说明可以走到这个格子的方法数是road[i-1][j]+road[i][j-1]。那么如何处理有障碍物的格子呢?这在我们的边缘初始化时就应该做好。先遍历第0行，如果有格子存在障碍物，就把可到达它的方法置为0，初始化第0列时也相同。当边缘初始化完成，那么往里面推进时，如果上一步（左或上）是障碍物，那么对应方向的路径数为0，说明无法从这个方向到达。当数组遍历完成后，road[m-1][n-1]就表示了走到这个终点可能存在的路径数 LeetCode 78. SubsetsQUESTION:Given a set of distinct integers, nums, return all possible subsets (the power set). Note: The solution set must not contain duplicate subsets. Example: Input: nums = [1,2,3]Output:[ [3], [1], [2], [1,2,3], [1,3], [2,3], [1,2], []] Code:123456789101112131415161718class Solution: def subsets(self, nums): """ :type nums: List[int] :rtype: List[List[int]] """ s=0 result=[] n=len(nums) while s&lt; (1&lt;&lt;n): temp=[] for i in range(n): if s &amp; (1&lt;&lt;i): temp.append(nums[i]) result.append(temp) #print(result) s=s+1 return result Explanation对于一个含有n个元素的集合，它的子集个数为2^n个，正好与0——2^n-1的数字个数相同。而且它的二进制的每一位都刚好对应一个元素。考虑 n=3 时，集合为{1，2，3}取6&lt;2^3,6的二进制为110，那么对应的子集为{2，3}取2，二进制为010，对应子集为{2}也就是说，0–2^n-1的每一个数的二进制都对应着一个子集的情况，1代表该元素存在，0代表该元素不在子集中。生成一个子集时，只需要判断该子集对应的数字的二进制在哪些位上为1，就去那个元素。根据这个思路，可获得全部子集。]]></content>
      <categories>
        <category>homework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[homework_week5]]></title>
    <url>%2F2018%2F04%2F08%2Fhomework-week5%2F</url>
    <content type="text"><![CDATA[Homework of Week 5Chapter 9 &amp;&amp; 10 9-1 餐馆 ：创建一个名为Restaurant 的类，其方法init() 设置两个属性：restaurant_name 和cuisine_type 。创建一个名为describe_restaurant() 的方法和一个名为open_restaurant() 的方法，其中前者打印前述两项信息，而后者打印一条消息，指出餐馆正在营业。根据这个类创建一个名为restaurant 的实例，分别打印其两个属性，再调用前述两个方法。9-2 三家餐馆 ：根据你为完成练习9-1而编写的类创建三个实例，并对每个实例调用方法describe_restaurant() 。9-3 用户 ：创建一个名为User 的类，其中包含属性first_name 和last_name ，还有用户简介通常会存储的其他几个属性。在类User 中定义一个名为describe_user() 的方法，它打印用户信息摘要；再定义一个名greet_user() 的方法，它向用户发出个性化的问候。 123456789101112131415161718192021222324252627282930313233343536373839class Restaurant(): def __init__(self,restaurant_name,cuisine_type): self.restaurant_name=restaurant_name self.cuisine_type=cuisine_type def describe_restaurant(self): print(self.restaurant_name) print(self.cuisine_type) def open_restaurant(self): print("The restaurant is open")restaurant_1=Restaurant("TaoTaoJu","Yuecai")restaurant_2=Restaurant("ZhiGuangGe","Guocai")restaurant_3=Restaurant("BaiTianE","Xican")restaurant_1.describe_restaurant()restaurant_1.open_restaurant()restaurant_2.describe_restaurant()restaurant_3.describe_restaurant()class User(): def __init__(self,first_name,last_name,age,job): self.first_name=first_name self.last_name=last_name self.age=age self.job=job def describe_user(self): print(self.first_name) print(self.last_name) print(self.age) print(self.job) def greet_uer(self): print("Hello",self.first_name)John=User("John","Steve",14,"Student")John.describe_user()John.greet_uer() result123456789101112TaoTaoJuYuecaiThe restaurant is openZhiGuangGeGuocaiBaiTianEXicanJohnSteve14StudentHello John 9-6 冰淇淋小店 ：冰淇淋小店是一种特殊的餐馆。编写一个名为IceCreamStand 的类，让它继承你为完成练习9-1或练习9-4而编写的Restaurant 类。这两个版本的Restaurant 类都可以，挑选你更喜欢的那个即可。添加一个名为flavors 的属性，用于存储一个由各种口味的冰淇淋组成的列表。编写一个显示这些冰淇淋的方法。创建一个IceCreamStand 实例，并调用这个方法。9-10 导入Restaurant 类 ：将最新的Restaurant 类存储在一个模块中。在另一个文件中，导入Restaurant 类，创建一个Restaurant 实例，并调用Restaurant 的一个方法，以确认import 语句正确无误 123456789101112131415from part1 import Restaurantclass IceCreamStand(Restaurant): def __init__(self,restaurant_name,cuisine_type,flavors): super().__init__(restaurant_name,cuisine_type) self.flavors=flavors def desrcibe_flavors(self): print("The kinds of icecream we can support are as following") for flavor in flavors: print(flavor)flavors=["Chocolate","Vanilla","Strawberry","Blueberry","Cream"]Myshop=IceCreamStand("Honey House","dessert",flavors)Myshop.describe_restaurant()Myshop.desrcibe_flavors() result12345678Honey HousedessertThe kinds of icecream we can support are as followingChocolateVanillaStrawberryBlueberryCream 10-1 Python学习笔记 ：在文本编辑器中新建一个文件，写几句话来总结一下你至此学到的Python知识，其中每一行都以“In Python you can”打头。将这个文件命名为learning_python.txt，并将其存储到为完成本章练习而编写的程序所在的目录中。编写一个程序，它读取这个文件，并将你所写的内容打印三次：第一次打印时读取整个文件；第二次打印时遍历文件对象；第三次打印时将各行存储在一个列表中，再在with 代码块外打印它们。 12345678910111213filename="Python.txt"with open(filename) as f_obj: contents=f_obj.read() print(contents)with open(filename) as f_obj: for line in f_obj: print(line.rstrip())with open(filename) as f_obj: lines=f_obj.readlines() print(lines) result123456789In Python you can do most of things done by C++In Python you can do a lot of intersting thingIn Python you can make a game easilyIn Python you can do most of things done by C++In Python you can do a lot of intersting thingIn Python you can make a game easily[&apos;In Python you can do most of things done by C++\n&apos;, &apos;In Python you can do a lot of intersting thing\n&apos;, &apos;In Python you can make a game easily&apos;]***Repl Closed*** 10-3 访客 ：编写一个程序，提示用户输入其名字；用户作出响应后，将其名字写入到文件guest.txt中。123456filename="User.txt"with open(filename,"w") as f: for i in range(3): name=input() f.write(name) f.write("\n") 10-6 加法运算 ：提示用户提供数值输入时，常出现的一个问题是，用户提供的是文本而不是数字。在这种情况下，当你尝试将输入转换为整数时，将引发TypeError 异常。编写一个程序，提示用户输入两个数字，再将它们相加并打印结果。在用户输入的任何一个值不是数字时都捕获TypeError 异常，并打印一条友好的错误消息。对你编写的程序进行测试：先输入两个数字，再输入一些文本而不是数字。12345678910while 1: try: a=input("Please input the first number:") b=input("Please input the second number :") int(a) int(b) except ValueError: print("Please input the number only") else : print(int(a)+int(b)) result123456789101112Please input the first number:11Please input the second number :2233Please input the first number:3Please input the second number :aaaPlease input the number onlyPlease input the first number:112Please input the second number :333445Please input the first number:asdasdaPlease input the second number :zxzzzPlease input the number only]]></content>
      <categories>
        <category>homework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[homework_week4]]></title>
    <url>%2F2018%2F04%2F01%2Fhomework-week4%2F</url>
    <content type="text"><![CDATA[Homework of week 4Chapter 7 &amp;&amp; Chapter 8 7-4 比萨配料 ：编写一个循环，提示用户输入一系列的比萨配料，并在用户输入’quit’ 时结束循环。每当用户输入一种配料后，都打印一条消息，说我们会在比萨中添加这种配料。 7-6 三个出口 ：以另一种方式完成练习7-4或练习7-5，在程序中采取如下所有做法。 在while 循环中使用条件测试来结束循环。 使用变量active 来控制循环结束的时机。 使用break 语句在用户输入’quit’ 时退出循环。 123456789101112131415161718while 1: chara=input("Please input the material you want to add: ") if chara=="quit": break print(chara,"will be added to your pizza")active=1while active: chara=input("Please input the material you want to add: ") if chara=="quit": active=0 continue print(chara,"will be added to your pizza")chara=chara=input("Please input the material you want to add: ")while chara!="quit": print(chara,"will be added to your pizza") chara=chara=input("Please input the material you want to add: ") result123456789101112131415Please input the material you want to add: addadd will be added to your pizzaPlease input the material you want to add: potatopotato will be added to your pizzaPlease input the material you want to add: quitPlease input the material you want to add: girlsgirls will be added to your pizzaPlease input the material you want to add: cherrycherry will be added to your pizzaPlease input the material you want to add: quitPlease input the material you want to add: suzisuzi will be added to your pizzaPlease input the material you want to add: beefbeef will be added to your pizzaPlease input the material you want to add: quit 7-8 熟食店 ：创建一个名为sandwich_orders 的列表，在其中包含各种三明治&gt;的名字；再创建一个名为finished_sandwiches 的空列表。遍历列表sandwich_orders ，对于其中的每种三明治，都打印一条消息，如I made &gt;your tuna sandwich ，并将其移到列表finished_sandwiches 。所有三明治都制作好后，打印一条消息，将这些三明治列出来 12345678sandwich_orders=["tuna sandwich","beef sandwich","tomato sandwich","egg sandwich"]finished_sandwiches=[]while sandwich_orders: temp=sandwich_orders.pop() print("I made your ",temp) finished_sandwiches.append(temp)print("I finish all sandwich orders") result12345I made your egg sandwichI made your tomato sandwichI made your beef sandwichI made your tuna sandwichI finish all sandwich orders 8-7 专辑 ：编写一个名为make_album() 的函数，它创建一个描述音乐专辑的字典。这个函数应接受歌手的名字和专辑名，并返回一个包含这两项信息的字典。使用这个函数创建三个表示不同专辑的字典，并打印每个返回的值，以核实字典正确地存储了专辑的信息。 给函数make_album() 添加一个可选形参，以便能够存储专辑包含的歌曲数。如果调用这个函数时指定了歌曲数，就将这个值添加到表示专辑的字典中。调用这个函数，并至少在一次调用中指定专辑包含的歌曲数。 8-8 用户的专辑 ：在为完成练习8-7编写的程序中，编写一个while 循环，让用户输入一个专辑的歌手和名称。获取这些信息后，使用它们来调用函数make_album() ，并将创建的字典打印出来。在这个while 循环中，务必要提供退出途径。 123456789101112131415161718192021def make_album(name,name_album,num=1): album=&#123;"name":name,"album":name_album,"number of songs":num&#125; return albumwhile 1 : name=input("Please input the name of the singer(input \"quit\" means leave):") if name=="quit": break album=input("Please input the name of the album : ") l=make_album(name,album) print(l) print('\n')print('\n')name=input("Please input the name of the singer(input \"quit\" means leave):")album=input("Please input the name of the album : ")num=input("Please input the number of the songs: ")l=make_album(name,album,num)print(l) result1234567891011121314151617Please input the name of the singer(input &quot;quit&quot; means leave):TalyorPlease input the name of the album : Reputation&#123;&apos;name&apos;: &apos;Talyor&apos;, &apos;album&apos;: &apos;Reputation&apos;, &apos;number of songs&apos;: 1&#125;Please input the name of the singer(input &quot;quit&quot; means leave):ironyPlease input the name of the album : Hope&#123;&apos;name&apos;: &apos;irony&apos;, &apos;album&apos;: &apos;Hope&apos;, &apos;number of songs&apos;: 1&#125;Please input the name of the singer(input &quot;quit&quot; means leave):quitPlease input the name of the singer(input &quot;quit&quot; means leave):AimerPlease input the name of the album : last stardustPlease input the number of the songs: 666&#123;&apos;name&apos;: &apos;Aimer&apos;, &apos;album&apos;: &apos;last stardust&apos;, &apos;number of songs&apos;: &apos;666&apos;&#125; 8-9 魔术师 ：创建一个包含魔术师名字的列表，并将其传递给一个名为show_magicians() 的函数，这个函数打印列表中每个魔术师的名字。8-10 了不起的魔术师 ：在你为完成练习8-9而编写的程序中，编写一个名为make_great() 的函数，对魔术师列表进行修改，在每个魔术师的名字中都加入字样“theGreat”。调用函数show_magicians() ，确认魔术师列表确实变了。123456789101112131415def show_magicians(name): for n in name: print(n)def make_great(names): i=0 for name in names: name="The Great "+name names[i]=name i+=1name=["Peter","Marcos","Jyaio"]show_magicians(name)make_great(name)show_magicians(name) result123456PeterMarcosJyaioThe Great PeterThe Great MarcosThe Great Jyaio 8-12 三明治 ：编写一个函数，它接受顾客要在三明治中添加的一系列食材。这个函数只有一个形参（它收集函数调用中提供的所有食材），并打印一条消息，对顾客点的三明治进行概述。调用这个函数三次，每次都提供不同数量的实参。12345678def sandwich(*agrc): for food in agrc: print(food," will be in your sandwich") print("Please take your sandwich and have fun\n")sandwich("potato","egg","meat")sandwich("bread")sandwich("cucmber","tomato") result1234567891011potato will be in your sandwichegg will be in your sandwichmeat will be in your sandwichPlease take your sandwich and have funbread will be in your sandwichPlease take your sandwich and have funcucmber will be in your sandwichtomato will be in your sandwichPlease take your sandwich and have fun]]></content>
      <categories>
        <category>homework</category>
      </categories>
      <tags>
        <tag>homework of python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Homework of Week3]]></title>
    <url>%2F2018%2F03%2F25%2FWeek3%2F</url>
    <content type="text"><![CDATA[Homework of Chapter 5 and Chapter 6Chapter 5QUESTION5-4 外星人颜色#2 ：像练习5-3那样设置外星人的颜色，并编写一个if-else 结构。如果外星人是绿色的，就打印一条消息，指出玩家因射杀该外星人获得了5个点。如果外星人不是绿色的，就打印一条消息，指出玩家获得了10个点。12345alien_color="green"if alien_color=="green": print("You kill a green alien and get 5 points")else: print("You kill a special alien and get 10 points") resut:1You kill a green alien and get 5 points QUESTION5-5 外星人颜色#3 ：将练习5-4中的if-else 结构改为if-elif-else 结构。如果外星人是绿色的，就打印一条消息，指出玩家获得了5个点。如果外星人是黄色的，就打印一条消息，指出玩家获得了10个点。如果外星人是红色的，就打印一条消息，指出玩家获得了15个点。 5-7 喜欢的水果 ：创建一个列表，其中包含你喜欢的水果，再编写一系列独立的if 语句，检查列表中是否包含特定的水果。将该列表命名为favorite_fruits ，并在其中包含三种水果。编写5条if 语句，每条都检查某种水果是否包含在列表中，如果包含在列表中，就打印一条消息，如“You really like bananas!”。 12345678910111213141516171819alien_color="red"if alien_color=="green": print("You kill a green alien and get 5 points")elif alien_color=="yellow": print("You kill a yellow alien and get 10 points")elif alien_color=="red": print("You kill a red alien and get 15 points")favourite_fruit=["apple","pear","orange"]if "apple" in favourite_fruit: print("You really like apple")if "banana" in favourite_fruit: print("You really like banana")if "pear" in favourite_fruit: print("You really like pear")if "blue berry" in favourite_fruit: print("You really like blue berry")if "orange" in favourite_fruit: print("You really like orange") result:1234You kill a red alien and get 15 pointsYou really like appleYou really like pearYou really like orange QUESTION5-8 以特殊方式跟管理员打招呼 ：创建一个至少包含5个用户名的列表，且其中一个用户名为’admin’ 。想象你要编写代码，在每位用户登录网站后都打印一条问候消息。遍历用户名列表，并向每位用户打印一条问候消息。如果用户名为’admin’ ，就打印一条特殊的问候消息，如“Hello admin, would you like to see a status report?”。否则，打印一条普通的问候消息，如“Hello Eric, thank you for logging in again”。 5-9 处理没有用户的情形 ：在为完成练习5-8编写的程序中，添加一条if 语句，检查用户名列表是否为空。如果为空，就打印消息“We need to find some users!”。删除列表中的所有用户名，确定将打印正确的消息。 5-10 检查用户名 ：按下面的说明编写一个程序，模拟网站确保每位用户的用户名都独一无二的方式。创建一个至少包含5个用户名的列表，并将其命名为current_users 。再创建一个包含5个用户名的列表，将其命名为new_users ，并确保其中有一两个用户名也包含在列表current_users 中。遍历列表new_users ，对于其中的每个用户名，都检查它是否已被使用。如果是这样，就打印一条消息，指出需要输入别的用户名；否则，打印一条消息，指出这个用户名未被使用。确保比较时不区分大消息；换句话说，如果用户名’John’ 已被使用，应拒绝用户名’JOHN’ 。123456789101112131415161718users=["admin","John","Alex","Akaxia","Michael"]for user in users: if user=="admin": print("Hello admin, would you like to see a status report?") else : print("Hello ",user,", thank you for logging in again”")users=[]if not users: print("We need some users")currnet_users=["admin","John","Alex","Akaxia","Michael"];new_users=["Liku","Siri","ALEX","Steve","michael"]for user in new_users: if user.upper() in [s.upper() for s in currnet_users ]: print("This user name has been signed up,please use another name") else: print("This user nams is availabe") Chapter 6QUESTION6-1 人 ：使用一个字典来存储一个熟人的信息，包括名、姓、年龄和居住的城市。该字典应包含键first_name 、last_name 、age 和city 。将存储在该字典中的每项信息都打印出来。12345friend=&#123;'first name':"lex",'last name':"Dior",'age':24,'city':'Shanghai'&#125;print(friend['first name'])print(friend['last name'])print(friend['age'])print(friend['city']) result:1234lexDior24Shanghai QUESTION6-4 词汇表2 ：既然你知道了如何遍历字典，现在请整理你为完成练习6-3而编写的代码，将其中的一系列print 语句替换为一个遍历字典中的键和值的循环。 6-5 河流 ：创建一个字典，在其中存储三条大河流及其流经的国家。其中一个键—值对可能是’nile’: ‘egypt’ 。使用循环为每条河流打印一条消息，如“The Nile runs through Egypt.”。使用循环将该字典中每条河流的名字都打印出来。使用循环将该字典包含的每个国家的名字都打印出来。12345678910111213141516key=&#123; 'if':"Conditional statements", 'list':'Basic data structure', 'for':'Loop statements' &#125;for word,use in key.items(): print(word,":",use)river=&#123;'nile': 'egypt','Changjiang':'China','Huanghe':'China'&#125;for r ,country in river.items(): print(r," runs thought ",country)for r in river.keys(): print(r)for country in river.values(): print(country) result:123456789101112if : Conditional statementslist : Basic data structurefor : Loop statementsnile runs thought egyptChangjiang runs thought ChinaHuanghe runs thought ChinanileChangjiangHuangheegyptChinaChina QUESTION6-9 喜欢的地方 ：创建一个名为favorite_places 的字典。在这个字典中，将三个人的名字用作键；对于其中的每个人，都存储他喜欢的1~3个地方。为让这个练习更有趣些，可让一些朋友指出他们喜欢的几个地方。遍历这个字典，并将其中每个人的名字及其喜欢的地方打印出来。123456favorite_place=&#123;"Ezio":["Roma","Istanbul","Florence"],"Alex":["Tokoyo","Britain","Avalon"],"Wangdaye":["Beijing","Xi'an","Tibet"]&#125;for name,places in favorite_place.items(): print(name) for place in places: print(place) print('\n') result:12345678910111213141516EzioRomaIstanbulFlorenceAlexTokoyoBritainAvalonWangdayeBeijingXi&apos;anTibet]]></content>
      <categories>
        <category>homework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[homework_week2]]></title>
    <url>%2F2018%2F03%2F17%2Fhomework-week2%2F</url>
    <content type="text"><![CDATA[Homework of Week 2##Q 3-1~3-3123456789names=["YeGuangzhi","Yinjiyi","Yangchenze"]print(names[0])print(names[1])print(names[2])for friend in names: print("Hello,", friend)Transpot=["biycle","car","plane"]for T in Transpot: print("I want to go home by ",T) ##Q 3-4~3-7123456789101112131415161718192021222324guest=["Mike","Stack","Ezio","Masiluo"]for g in guest: print("I would like to invite you to attend my party," , g)print(guest[0],"can't come")guest[0]="White_Wolf"for g in guest: print("I would like to invite you to attend my party," , g)print("I find a better table")guest.insert(0,"Bayoneta")guest.insert(2,"Steve")guest.append("Taloyer")for g in guest: print("I would like to invite you to attend my party," , g)print(len(guest))print("For some unknown reason,I can only invite two people")for g in guest[2:]: print("I am sorry about that",g) guest.pop()print(guest[0],"is in the list ")print(guest[1],"is in the list")del guest[1]del guest[0]if not guest: print("The list is empty") ##Q 3-8、4-10123456789101112131415161718192021place=["Haerbin","Tibet","Changsha","Janpan","Europe"]print(place)print(sorted(place))print(place)print(sorted(place,reverse=True))print(place)place.reverse()print(place)place.reverse()print(place)print(place)place=sorted(place)print(place)place=sorted(place,reverse=True)print(place)M1="The first three items in the list are"M2="Three items from the middle of the list are:"M3="The last three items in the list are"print(M1,place[:3])print(M2,place[1:-1])print(M3,place[-3:]) ##Q 4-3~4-9123456789101112for i in range(1,20): print(i)l=range(1,1000000)print(min(l))print(max(l))print(sum(l))l=range(1,20,2)for num in l: print(num)k=[i**3for i in range(1,10)]for num in k: print(num)]]></content>
      <categories>
        <category>homework</category>
      </categories>
      <tags>
        <tag>Python homework</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python Homework of Week 1]]></title>
    <url>%2F2018%2F03%2F09%2F2018-03-09-Homework-Week-1%2F</url>
    <content type="text"><![CDATA[Homework of Week 1Question:2-1,2-2 1234message="hello world"print(message)message="World is cruel"print(message) Question:2-3,2-4,2-5,2-7,2-1012345678910111213141516171819name="YeZihao"print("Hello ",name, ",would you like to learn some Python today?")print(name.title())print(name.upper())print(name.lower())print("Ezio Auditore Da Firenze said:\"Twenty two years ago, I stood where I stand now,\and watched my beloved died, betrayed by those I have called friends.\Avengence clouded my mind, it would cosumed me, were if not for the wisdom of a few strangers. \Who taught me to look past my instincts.They never preached answers, but guided me to learn from my self. \We don't need anyone to tell us what to do. Not Savonarola or the Medici. We are free to follow our own path. \There are those who will take that freedom from us, and too many of you gladly give it. \But it is our ablity to choose - whatever you think is true - that makes us human.\There is no book or teacher to give you the answers, to show you the path. \Choose your own way.Do not follow me, or anyone else.\" ")famous_name="\nEzio Auditore Da Firenze \t" #上面一堆的\是用于美观print(famous_name)print(famous_name.lstrip())print(famous_name.rstrip())print(famous_name.strip()) Question:2-8,2-9123456print(5+3)print(10-2)print(2*4)print(int(16/2))num=1024print("My favorite number is ",str(num) ) Import this123456789101112131415161718192021The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&apos;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&apos;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&apos;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&apos;s do more of those!]]></content>
      <categories>
        <category>homework</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Python & My Though]]></title>
    <url>%2F2018%2F03%2F06%2F2017-11-30-Hello-Blog%2F</url>
    <content type="text"><![CDATA[Python Python给我的第一印象，是一门简化了许多，更为接近人类表达想法的编程语言。或者说，比起C++，我感觉python像一种可以随时根据需求变成各种模样的万用工具，人们很多时候不需要知道工具工作的详细原理，只要知道它怎么使用就好了，而C++则像一堆元件，利用这堆元件我们能搭建起更贴切符合要求的工具，但这个搭建的过程并不容易，至少对于很多人来说直接使用现成的工具比自己从头搭建更加方便。当然我也不是说python不能像C++那样自己搭建工具（那些大量的第三方库就是大佬们用python搭好的工具），但那不是python的突出优点。Python的优点应该是更加简单易用，更又助于加快开发软件的速度。 好吧。上面python的优点是我在官网上和其他地方看来得。作为先学了C++的人，我再去学python，说实话我感觉各种不适应，可能是我还没有从C++的惯性思维里挣脱出来，所以自学python的时候经常感觉还不如C++好写。但我也明白这是我python并未真正熟练掌控的缘故，可能这个学期学完后我就会彻底叛变到python阵营。 Python感觉是一栋大厦，很多人都在为它添砖加瓦，官网的社区里也有很多入门的教程，我想入门python应该不会太难。 Target 这个学期我希望自己能熟练地使用python这门语言吧，很多已经能熟练地用python做很多事的大佬们都说python是一门能做很多事情的语言，只有不断去用，才能真正地熟练地掌控，光看教程是没什么用的。我希望这个学期后我能用python写一款自己的图像处理软件，相当于一个滤镜，这是我的最终愿望了（暂定）。至于更高级的东西，学校教的都没有学好，我真的没有余力去学那些大佬参加比赛或者其他之类的，但怎么说，努力吧。]]></content>
      <categories>
        <category>homework</category>
      </categories>
  </entry>
</search>
